{"meta":{"title":"MrAir Blog","subtitle":"","description":"","author":"mrair","url":"https://owenstake.github.io","root":"/"},"pages":[],"posts":[{"title":"nini at work","slug":"Nini-at-work","date":"2021-04-12T07:14:54.000Z","updated":"2021-04-12T08:38:49.470Z","comments":true,"path":"2021/04/12/Nini-at-work/","link":"","permalink":"https://owenstake.github.io/2021/04/12/Nini-at-work/","excerpt":"","text":"welcome nini今天是倪倪上班的第一天，培训球","categories":[],"tags":[{"name":"nini","slug":"nini","permalink":"https://owenstake.github.io/tags/nini/"}]},{"title":"leetcode","slug":"leetcode","date":"2021-04-12T07:14:54.000Z","updated":"2021-04-12T08:39:12.450Z","comments":true,"path":"2021/04/12/leetcode/","link":"","permalink":"https://owenstake.github.io/2021/04/12/leetcode/","excerpt":"","text":"高频： 宽度优先搜索（BFS） 深度优先搜索（DFS） 二分法（Binary Search） 熟悉 双指针（2 Pointer） 堆、栈、队列、哈希表（Heap，Stack，Heap，HashMap/HashSet） 前缀和（Prefix Sum） 链表（LinkedList） 熟练 二叉树（Binary Tree） 二叉搜索树（Binary Search Tree） 快速排序与归并排序（Quick Sort/ Merge Sort） 中频：动态规划（DP），扫描线（Sweep Line），字典树（Trie），并查集（Union Find），单调栈与单调队列（Monotone Stack/ Queue），TreeMap等 低频：Dijkstra，树状数组，线段树，最小生成树等… 高频门类 基础套路熟悉 熟悉 （看过一遍） 熟练（做过一遍） 熟练(系统做过一遍) 宽度优先搜索（BFS） Y 深度优先搜索（DFS） Y 二分法（Binary Search） 熟悉 Y Y 双指针（2 Pointer） Y 堆、栈、队列、哈希表（Heap，Stack，Heap，HashMap/HashSet） Y 前缀和（Prefix Sum） Y 链表（LinkedList） Y Y Y Y 二叉树（Binary Tree） Y Y 二叉搜索树（Binary Search Tree） Y Y 快速排序与归并排序（Quick Sort/ Merge Sort） Y Y 小结查询表问题 重复数问题 查找重复数 O(n^2) -&gt; O(n*lgN) -&gt; O(n) 查找相距k内的重复数。定长滑动窗口。 nsum 两数之和 O(n^2) -&gt; O(nlgN) -&gt; O(n) 三数之和 O(n^3) -&gt; O(n^2*lgN) -&gt; O(n^2) 四数之和 O(n^4) -&gt; O(n^3*lgN) -&gt; O(n^2) 四数相加 优化思路。优化查询效率: O(n) -&gt; O(lgN) -&gt; O(1) 暴力穷举 二分法 + 排序 hash表 小技巧，map键值 设置技巧。 桶排序键值设置，如上1.2题目 异位字符创，键值映射 下一步刷题：数据结构设计，挺有意思的，比如LRU。 c++语法特性迭代器// 迭代器失效 情况 分为 关联性容器和其他。关联性容器 迭代器好用(可当做指针用)，其他则会随着resize失效。 两大重要容器 list dequeue// 值得一提的是，list 容器在进行插入（insert()）、接合（splice()）等操作时，都不会造成原有的 list 迭代器失效，甚至进行删除操作，而只有指向被删除元素的迭代器失效，其他迭代器不受任何影响。 // list双向链表的迭代器还是挺好用的，够持久的。完全可以当做指针来用。 要保存倒数 最小的两个元素。 命中时，不需要删除元素，只是更新下 元素频次和 最小频次。 增加时，需要增加元素，更新下元素频次。若发现超容量，则需删除最小频次元素，并将二小元素 置为最小。 特殊数据结构构造哈希链表 LRUcachelfu分析 操作 复杂度要求 查找 插入 O(1) 删除 O(1) 随机访问 无需 插入和删除、是否随机访问决定了 存储容器 =&gt; 链表or数组 查找决定要不要上hashtable 综上，lfu是底层存储 采用 链表list。 采用关联方式 umap。 key2val val2node freq2node 并查集 - 中频以后再说 - 低频 不用扣 语法细节，这是不通用的东西（局限于c++而已），能实现 最优复杂度的解法就可以了，不一定要击败双百。 很多语法技巧，只要了解到就可以了，无需应用起来，增加思维负担。 滑动窗口KMPthe key point is find the longest common prefix suffix except the string itself. 并非要按顺序访问，我们只要 按顺序输出就可以了。 B树索引文件的组织，一般都是采用B树来组织。 索引文件一般都是很大的。 索引文件中都保存一个索引元素(key-value)。 所有文件们都保存着 节点们NODE。 索引文件就是保存着一棵树。对外表现，就是一个表。 这个表，描述的就是 key-value的关系数据。 这个索引表，提供高速增删改查的能力。 如果采用向量的方式，插入删除的复杂度太高。 采用树的形式最好了。这样索引表中的数据就采用树组织 元素们的结构。 因为这个索引表一般都很庞大，超过内存的大小。表征 就是索引文件很大，无法一次性都加载进内存。 在这里，我们做一个假设，内存只能存储一个节点node。查找key时，从根结点出发，加载根结点，然后根据需要，再加载子节点。每一个加载过程，都是一次io过程，都是比较耗时的。所以我们的单节点中，包含的信息越多越好，减少加载子节点的次数。 索引表 本身就是固化为文件，存储在磁盘上。 key-value 文件名-物理地址 b树就是减少io次数。 因为多叉树没有中序遍历，导致b树无法 难以循序输出。b+树解决这个问题。 数据库索引 index node 关注高性能mysql，很有意思 万物皆文本，不要硬编码","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://owenstake.github.io/tags/leetcode/"}]}],"categories":[],"tags":[{"name":"nini","slug":"nini","permalink":"https://owenstake.github.io/tags/nini/"},{"name":"leetcode","slug":"leetcode","permalink":"https://owenstake.github.io/tags/leetcode/"}]}